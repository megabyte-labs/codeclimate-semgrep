"""Package initialisation and support for mapping from Semgrep to CC results"""
import functools
import pathlib
import types
from typing import Any, Callable, Dict, List

from jsonschema import validate  # type: ignore

# Ignore due to what may be a mypy bug, since pyright type checks this just
# fine: https://github.com/python-poetry/poetry/issues/3094
from ..semgrep import output as semgrep  # type: ignore[import]
from . import config
from . import output as _output
from .config import Config
from .output import Category, Location, Output, Position, Positions, Severity, TypeEnum

AnyDict = Callable[..., Dict[Any, Any]]


def _dropempty(wrapped_fn: AnyDict) -> AnyDict:
    """Decorate a Dict-returning arg to drop keys with `None` values

    Args:
        wrapped_fn: A functioning taking any arguments and returning a `Dict`.
    Returns:
        The function, decorated to drop keys with `None` values from the return
        value.
    """

    @functools.wraps(wrapped_fn)
    def wrapper(*args: List[Any], **kwargs: Dict[Any, Any]) -> Dict[Any, Any]:
        return {k: v for k, v in wrapped_fn(*args, **kwargs).items() if v is not None}

    return wrapper


def _fix_to_dict(cls: type):
    """Fix to_dict methods on quicktype-generated classes to not contain None values

    The Code Climate engine support doesn't dig on JSON that contains None/null
    values for optional object items. The `to_dict` methods generated by
    quicktype, however, include these values. This takes a class with a
    `to_dict` method and wraps it so that keys with `None`-values are dropped.

    Args:
        cls: The class to patch.
    """
    to_dict = getattr(cls, "to_dict")
    if to_dict is None or not isinstance(to_dict, types.FunctionType):
        raise RuntimeError("cls must have a to_dict method")

    setattr(cls, "to_dict", _dropempty(to_dict))


def _fix_module(mod: types.ModuleType):
    """Fix a quicktype-generated module's `to_dict` methods.

    Args:
        mod: The quicktype-generated module to patch.
    """
    for val in vars(mod).values():
        if isinstance(val, type) and hasattr(val, "__dataclass_params__"):
            _fix_to_dict(val)


def _location_from_semgrep_result(
    result: semgrep.Result, rundir: pathlib.Path
) -> Location:
    """Build a Code Climate Location from a Semgrep result

    Args:
        result: The Semgrep-provided Result.
        rundir: The base directory of the code that was analysed.

    Returns:
        A Code Climate engine Location.
    """

    path = pathlib.Path(result.path).relative_to(rundir)

    return Location(
        path=str(path),
        positions=Positions(
            begin=Position(line=result.start.line, column=result.start.col),
            end=Position(line=result.end.line, column=result.end.col),
        ),
    )


_DEFAULT_CATEGORIES = [Category.BUG_RISK]


def _categories_from_semgrep_result(result: semgrep.Result) -> List[Category]:
    """Determine Code Climate category for a Semgrep result

    Uses a sensible default if no Code Climate category was specified in the
    Semgrep rule metadata, since Semgrep doesn't have an intrinsic notion of
    finding "categories".

    Args:
        result: The Semgrep-provided Result.

    Returns:
        A list of Code Climate issue categories.
    """
    if result.extra.metadata.cc_categories is None:
        return _DEFAULT_CATEGORIES

    return [
        Category(category.value) for category in result.extra.metadata.cc_categories
    ]


_SEMGREP_SEVERITY_MAP = {
    semgrep.Severity.WARNING: Severity.MINOR,
    semgrep.Severity.ERROR: Severity.MAJOR,
    semgrep.Severity.INFO: Severity.INFO,
}


def _severity_from_semgrep_result(result: semgrep.Result) -> Severity:
    """Determine Code Climate severity for a Semgrep result

    Uses a default mapping of Semgrep severities to Code Climate severities,
    allowing an override via the Semgrep result metadata since the Code Climate
    severity list is more exhaustive.

    Args:
        result: The Semgrep-provided Result.

    Returns:
        A Code Climate severity level.
    """
    if result.extra.metadata.cc_severity is not None:
        return Severity(result.extra.metadata.cc_severity.value)

    return _SEMGREP_SEVERITY_MAP[result.extra.severity]


def output_from_semgrep_result(result: semgrep.Result, rundir: pathlib.Path) -> Output:
    """Create Code Climate issue output from a Semgrep result

    Args:
        result: The Semgrep-provided Result.
        rundir: The base directory of the code that was analysed.

    Returns:
        An object suitable for serialization to JSON and emitted as a Code
        Climate issue.
    """
    check_id = result.check_id
    if check_id == "-":
        check_id = "InlinePattern"

    check_name = f"Semgrep/{check_id}"

    return Output(
        type=TypeEnum.ISSUE,
        location=_location_from_semgrep_result(result, rundir=rundir),
        categories=_categories_from_semgrep_result(result),
        severity=_severity_from_semgrep_result(result),
        check_name=check_name,
        description=result.extra.message,
    )


def config_from_dict(config_dict: Dict[Any, Any]) -> Config:
    """Parse configuration for this engine from a Dict

    This will also validate the configuration against our configuration schema
    for this engine.

    Args:
        config_dict: The configuration for this engine.

    Returns:
        Configuration for this engine.
    """
    validate(config_dict, schema=config.SCHEMA)

    return config.config_from_dict(config_dict)


_fix_module(_output)
